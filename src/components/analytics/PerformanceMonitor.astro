---
// Performance monitoring and analytics utilities
export interface Props {
  trackingId?: string;
  enableCLS?: boolean;
  enableFCP?: boolean;
  enableLCP?: boolean;
  enableFID?: boolean;
  enableTTFB?: boolean;
}

const { 
  trackingId,
  enableCLS = true,
  enableFCP = true, 
  enableLCP = true,
  enableFID = true,
  enableTTFB = true
} = Astro.props;
---

<!-- Performance Monitoring Script -->
<script define:vars={{ trackingId, enableCLS, enableFCP, enableLCP, enableFID, enableTTFB }}>
  // Core Web Vitals monitoring
  class PerformanceMonitor {
    constructor() {
      this.metrics = {};
      this.init();
    }

    init() {
      // Measure Time to First Byte (TTFB)
      if (enableTTFB) {
        this.measureTTFB();
      }

      // Measure First Contentful Paint (FCP)  
      if (enableFCP) {
        this.measureFCP();
      }

      // Measure Largest Contentful Paint (LCP)
      if (enableLCP) {
        this.measureLCP();
      }

      // Measure First Input Delay (FID)
      if (enableFID) {
        this.measureFID();
      }

      // Measure Cumulative Layout Shift (CLS)
      if (enableCLS) {
        this.measureCLS();
      }

      // Monitor resource loading
      this.monitorResources();
      
      // Send metrics when page unloads
      window.addEventListener('beforeunload', () => this.sendMetrics());
    }

    measureTTFB() {
      if ('navigation' in performance) {
        const navTiming = performance.getEntriesByType('navigation')[0];
        if (navTiming) {
          this.metrics.ttfb = navTiming.responseStart - navTiming.requestStart;
        }
      }
    }

    measureFCP() {
      if ('PerformanceObserver' in window) {
        const observer = new PerformanceObserver((list) => {
          for (const entry of list.getEntries()) {
            if (entry.name === 'first-contentful-paint') {
              this.metrics.fcp = entry.startTime;
              observer.disconnect();
            }
          }
        });
        observer.observe({ entryTypes: ['paint'] });
      }
    }

    measureLCP() {
      if ('PerformanceObserver' in window) {
        const observer = new PerformanceObserver((list) => {
          const entries = list.getEntries();
          const lastEntry = entries[entries.length - 1];
          this.metrics.lcp = lastEntry.startTime;
        });
        observer.observe({ entryTypes: ['largest-contentful-paint'] });
        
        // Stop observing after page load
        window.addEventListener('load', () => {
          setTimeout(() => observer.disconnect(), 0);
        });
      }
    }

    measureFID() {
      if ('PerformanceObserver' in window) {
        const observer = new PerformanceObserver((list) => {
          for (const entry of list.getEntries()) {
            this.metrics.fid = entry.processingStart - entry.startTime;
            observer.disconnect();
          }
        });
        observer.observe({ entryTypes: ['first-input'] });
      }
    }

    measureCLS() {
      if ('PerformanceObserver' in window) {
        let clsValue = 0;
        let clsEntries = [];
        
        const observer = new PerformanceObserver((list) => {
          for (const entry of list.getEntries()) {
            if (!entry.hadRecentInput) {
              clsValue += entry.value;
              clsEntries.push(entry);
            }
          }
          this.metrics.cls = clsValue;
        });
        
        observer.observe({ entryTypes: ['layout-shift'] });
      }
    }

    monitorResources() {
      if ('PerformanceObserver' in window) {
        const observer = new PerformanceObserver((list) => {
          const resources = {};
          for (const entry of list.getEntries()) {
            const resourceType = entry.initiatorType || 'other';
            if (!resources[resourceType]) {
              resources[resourceType] = { count: 0, totalSize: 0, totalTime: 0 };
            }
            resources[resourceType].count++;
            resources[resourceType].totalSize += entry.transferSize || 0;
            resources[resourceType].totalTime += entry.duration || 0;
          }
          this.metrics.resources = resources;
        });
        observer.observe({ entryTypes: ['resource'] });
      }
    }

    sendMetrics() {
      if (Object.keys(this.metrics).length > 0) {
        // Send to analytics service
        if (trackingId && typeof gtag !== 'undefined') {
          // Google Analytics 4 custom events
          Object.entries(this.metrics).forEach(([metric, value]) => {
            if (typeof value === 'number') {
              gtag('event', 'web_vital', {
                name: metric,
                value: Math.round(value),
                custom_parameter_1: window.location.pathname
              });
            }
          });
        }

        // Send to custom endpoint for monitoring
        if ('navigator' in window && 'sendBeacon' in navigator) {
          const data = JSON.stringify({
            url: window.location.href,
            userAgent: navigator.userAgent,
            timestamp: Date.now(),
            metrics: this.metrics
          });
          
          navigator.sendBeacon('/api/analytics/performance', data);
        }

        // Console log for development
        if (window.location.hostname === 'localhost') {
          console.table(this.metrics);
        }
      }
    }

    // Public method to get current metrics
    getMetrics() {
      return { ...this.metrics };
    }
  }

  // Initialize performance monitoring
  document.addEventListener('DOMContentLoaded', () => {
    window.performanceMonitor = new PerformanceMonitor();
  });

  // Resource hints for critical resources
  const criticalResources = [
    { rel: 'preload', href: '/fonts/inter-var.woff2', as: 'font', type: 'font/woff2', crossorigin: '' },
    { rel: 'preload', href: '/css/critical.css', as: 'style' }
  ];

  criticalResources.forEach(resource => {
    const link = document.createElement('link');
    Object.entries(resource).forEach(([key, value]) => {
      link.setAttribute(key, value);
    });
    document.head.appendChild(link);
  });

  // Service Worker registration for caching
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
      navigator.serviceWorker.register('/sw.js')
        .then(registration => {
          console.log('SW registered: ', registration);
        })
        .catch(registrationError => {
          console.log('SW registration failed: ', registrationError);
        });
    });
  }
</script>

<!-- Prefetch DNS for external resources -->
<link rel="dns-prefetch" href="//fonts.googleapis.com">
<link rel="dns-prefetch" href="//fonts.gstatic.com">
<link rel="dns-prefetch" href="//www.googletagmanager.com">
<link rel="dns-prefetch" href="//graph.instagram.com">

<!-- Preload critical CSS -->
<link rel="preload" href="/css/critical.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="/css/critical.css"></noscript>